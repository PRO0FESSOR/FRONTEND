
// oneshot typescript

- Values in javascript have observable behaviour based on the operation .
- Behaviour depends on the type of the value (eg: callable or properties).
- Errors (eg type error) occurs when the operations mismatch the value type.
- Javascript uses dynamic typing (errors appears at the run time).
- Typescript is used for the static typing , which predicts the errors before the runtime.
- Identifies errror (eg callables or non callable value) before running code .
- Helps catched bugs like typos , uncalled functions or logical errors.
- Typescript tooling enhances development with features like error detection , code complition , code fixes and navigation.
- We can install typescript using npm in our system . 
- File extention of typescript file is ts.
- We can compile ts file using tsc file.ts.
- We write code in the ts file , we can see the errors emmiting while writing then we can complile our ts file which tranform it into compatible javascript .
- Explicit types ,  mentioning types using : , example :string .
- Process of using explicit type is known as type annotation .
- Erased types - browsers are compatible to run js code only so ts code is erased during compilation and creates modified js .
- The process of moving from a newer or “higher” version of ECMAScript down to an older or “lower” one is sometimes called downleveling in typescript.
- Downleveling happens for the compatibility of the browsers so that our js code runs without any problem .
- Ts defaultly targets es5 , we can choose our custom es version using target ex -> --target es2015 .
- Inferred types - when we dont assign any type explicitly then ts uses the type from the value assigned . 
- Strictness in TypeScript refers to enabling strict type-checking options, improving type safety and catching potential errors early.
- NoImplicitAny prevents variables from being implicitly assigned the any type .
- strictNullChecks ensures null and undefined are not assignable to other types. 
- Ts primitive and non primitive types are same .
- Any type - TypeScript also has a special type, any, that you can use whenever you don’t want a particular value to cause typechecking errors.
- We can use type annotation for the variables like with var let and const .
- We can use type annotation is function parameter .
- We can also use type annotation for the function return type .
- For async functions we can explicitly define - Promise<number> as a type annotation .
- Anonymous function are func with no parameter type annotation , these functions works on the inferred type .
- We can use type annotation with the object properties , optional properties and default properties .
- Union type is a type in ts which forms using two or more types , it is a way of type annotation which uses more than one type , we can use it using a pipe - | , ex - id : number | string .
- We’ve been using object types and union types by writing them directly in type annotations. This is convenient, but it’s common to want to use the same type more than once and refer to it by a single name.
- A type alias is exactly that - a name for any type , example - type id = number | string now we can use id as a type annotation .
- We can use type aliases to create custom types which we can use again and again , type aliases can be used to create a type for the object .
- An interface declaration is another way to name an object type , syntax - interface details = {}.
- Type aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an interface are available in type, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.
- We can extend an interface using extends keyword and extend types using & (type bear = animal & {} ).
- For a situation when we have information about the type of a value that TypeScript can’t know about , in this situation, we can use a type assertion to specify a more specific type .
- Type asseertion example - const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement .
- Literal Types - in addition to the general types string and number, we can refer to specific strings and numbers in type positions.
- By combining literals into unions, you can express a much more useful concept - for example, functions that only accept a certain set of known values .
- Example - alignment: "left" | "right" | "center" .
- Writing ! after any expression is effectively a type assertion that the value isn’t null or undefined , example console.log(x!.toFixed()) .
- Enums are a feature added to JavaScript by TypeScript which allows for describing a value which could be one of a set of possible named constants.
- Numerical enums example -  enum Direction {
  Up = 1,
  Down,
  Left,
  Right,
}
- We know we can use two types simuntaneously using union types but if there isa function which uses string method to change string will give error if value provided is number . 
- So we have to explicitly check a type before using a value .
- Within our if check, TypeScript sees typeof value === dataType and understands that as a special form of code called a type guard.
- Ts looks at these special checks (called type guards) and assignments, and the process of refining types to more specific types than declared is called narrowing.
- typeof type guards

    "string"
    "number"
    "bigint"
    "boolean"
    "symbol"
    "undefined"
    "object"
    "function"

- In js null is of type object so if a value can be null , string , string[] and inside function when we explicitly check for type object to perform action on string[] array then ts generate error that value is possibly null , so also need to check explicitly that vale exist or not .
- Truthiness narrowing is to check weather value exist or not inside if block .
- Equality narrowing to narrow types based on - == like if x==y(same types)
- "in operator" narrowing is used to narrow types based on - in keyword like (address in details)
- We can also use instanceOf operator to narrow types if a value1 is a instanceOf value2 , like x instanceof Foo checks whether the prototype chain of x contains Foo.prototype .
- When we assign to any variable, TypeScript looks at the right side of the assignment and narrows the left side appropriately.
- Control flow - TypeScript's type system analyzes code flows to refine and narrow types dynamically.
- Type predicates in TypeScript are special return types for functions that allow narrowing within conditional checks, using the syntax param is Type, ensuring TypeScript recognizes a specific type after the function returns true.
- Discriminated unions in TypeScript narrowing refer to a pattern where a union of object types shares a common distinguishing property (discriminator) with literal values, allowing TypeScript to narrow types based on that property.
- When narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left. In those cases, TypeScript will use a never type to represent a state which shouldn’t exist.
- The never type is assignable to every type; however, no type is assignable to never (except never itself). This means you can use narrowing and rely on never turning up to do exhaustive checking in a switch statement.











